{"updatedAt":"2026-02-22T01:00:10.480Z","createdAt":"2026-02-19T12:30:26.340Z","id":"1ynOLUqzJRBweKUj","name":"Phase 2 - Document Categorizer + Dimension Dispatch ANK","description":null,"active":true,"isArchived":false,"nodes":[{"parameters":{"inputSource":"passthrough"},"type":"n8n-nodes-base.executeWorkflowTrigger","typeVersion":1.1,"position":[-3472,32],"id":"1d972686-f4ec-42eb-9c1d-4abee9e7c86a","name":"From Document Processor"},{"parameters":{"jsCode":"// Initialize workflow with input from Document Processor\nconst staticData = $getWorkflowStaticData('global');\nconst input = $input.first().json;\n\n// Store IDs\nstaticData.assessmentId = input.assessmentId;\nstaticData.versionId = input.versionId;\nstaticData.organizationId = input.organizationId;\nstaticData.documents = input.documents || [];\n\nconsole.log(`Document Categorizer initialized`);\nconsole.log(`Assessment: ${staticData.assessmentId}`);\nconsole.log(`Version: ${staticData.versionId}`);\nconsole.log(`Documents to categorize: ${staticData.documents.length}`);\n\nreturn [{\n  json: {\n    assessmentId: staticData.assessmentId,\n    versionId: staticData.versionId\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-3200,32],"id":"ac646a79-64fa-47c0-a1bc-34f9ee78f395","name":"Initialize"},{"parameters":{"operation":"get","tableId":"assessments","filters":{"conditions":[{"keyName":"id","keyValue":"={{ $json.assessmentId }}"}]}},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-3024,32],"id":"e2b96b72-f07b-4e67-be1b-caf1c7be9ef3","name":"Get Assessment","credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"jsCode":"// Check if we should use variant or base playbook\nconst assessment = $input.first().json;\n\nconst hasVariant = !!assessment.playbook_variant_id;\nconst hasCachedContent = !!assessment.playbook_content;\n\nconsole.log(`Assessment: ${assessment.id}`);\nconsole.log(`Has variant: ${hasVariant}`);\nconsole.log(`Has cached content: ${hasCachedContent}`);\n\n// If content is cached on assessment, we can skip fetching playbook\nif (hasCachedContent) {\n  return [{\n    json: {\n      ...assessment,\n      _source: 'cached',\n      _skipFetch: true\n    }\n  }];\n}\n\n// Otherwise, return with routing info\nreturn [{\n  json: {\n    ...assessment,\n    _source: hasVariant ? 'variant' : 'base',\n    _skipFetch: false,\n    _fetchId: hasVariant ? assessment.playbook_variant_id : assessment.playbook_id\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2848,32],"id":"78991078-800d-4e8b-9523-a14f92ede66b","name":"Check Variant"},{"parameters":{"jsCode":"// Extract dimensions from playbook (variant or base)\nconst staticData = $getWorkflowStaticData('global');\nconst assessment = $('Get Assessment').first().json;\n\n// Check which playbook source we have\nconst hasVariant = !!assessment.playbook_variant_id;\nconst playbookContent = assessment.playbook_content; // Cached on assessment\n\nlet dimensions = [];\nlet playbookName = '';\nlet playbookType = '';\n\n// If playbook_content is cached on assessment, use it directly\nif (playbookContent) {\n  let content = playbookContent;\n  if (typeof content === 'string') {\n    content = JSON.parse(content);\n  }\n  dimensions = content.dimensions || [];\n  playbookName = content.metadata?.name || 'Cached Playbook';\n  playbookType = content.metadata?.playbook_type || assessment.assessment_type;\n  console.log('Using cached playbook_content from assessment');\n} else {\n  // Otherwise use the input from Get Playbook/Variant node\n  const playbook = $input.first().json;\n  let content = playbook.content;\n  if (typeof content === 'string') {\n    content = JSON.parse(content);\n  }\n  dimensions = content.dimensions || [];\n  playbookName = playbook.name || playbook.variant_name || 'Unknown';\n  playbookType = playbook.playbook_type || assessment.assessment_type;\n}\n\n// Store dimensions in static data\nstaticData.dimensions = dimensions.map(d => ({\n  key: d.key || d.dimension_key,\n  name: d.name || d.dimension_name,\n  weight: d.weight || d.dimension_weight,\n  description: d.description || ''\n}));\n\nstaticData.playbookName = playbookName;\nstaticData.playbookType = playbookType;\nstaticData.hasVariant = hasVariant;\n\nconsole.log(`Playbook: ${playbookName} (variant: ${hasVariant})`);\nconsole.log(`Dimensions found: ${staticData.dimensions.length}`);\nstaticData.dimensions.forEach(d => {\n  console.log(`  - ${d.key}: ${d.name}`);\n});\n\nreturn [{\n  json: {\n    assessmentId: staticData.assessmentId,\n    versionId: staticData.versionId,\n    playbookName: playbookName,\n    hasVariant: hasVariant,\n    dimensionCount: staticData.dimensions.length,\n    dimensions: staticData.dimensions\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-1664,32],"id":"f8eedf17-a7cd-4f68-b22e-2bd9b2410d9f","name":"Extract Dimensions"},{"parameters":{"operation":"getAll","tableId":"document_metadata","returnAll":true,"filters":{"conditions":[{"keyName":"version_id","condition":"eq","keyValue":"={{ $('From Document Processor').first().json.versionId }}"}]}},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-1424,32],"id":"3150008c-91b6-48e4-8d7d-679cc13bbaab","name":"Get Documents","credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"jsCode":"// Filter out documents that already have dimension assignments\nconst staticData = $getWorkflowStaticData('global');\nconst documents = $input.all().map(item => item.json);\n\nconsole.log(`Found ${documents.length} documents for this version`);\n\n// Store document IDs for checking existing assignments\nconst documentIds = documents.map(d => d.id);\nstaticData.allDocumentIds = documentIds;\n\n// Pass through to check existing assignments\nreturn [{\n  json: {\n    documentIds: documentIds,\n    versionId: staticData.versionId,\n    documentCount: documents.length\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-1184,32],"id":"8ae79f6e-cce0-451b-9bdf-c9be440eda84","name":"Collect Doc IDs"},{"parameters":{"operation":"getAll","tableId":"document_dimension_assignments","returnAll":true,"filterType":"string","filterString":"=version_id=eq.{{ $('From Document Processor').first().json.versionId }}"},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-944,32],"id":"aeca0f8c-4bd9-4ddf-b939-5c33e975d0f4","name":"Get Existing Assignments","executeOnce":false,"alwaysOutputData":true,"credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}},"onError":"continueRegularOutput"},{"parameters":{"jsCode":"// Filter to only unprocessed documents AND include dimensions\nconst staticData = $getWorkflowStaticData('global');\nconst existingAssignments = $input.all().map(item => item.json).filter(item => item.document_id);\n\n// Get unique document IDs that already have assignments\nconst processedDocIds = new Set(existingAssignments.map(a => a.document_id));\n\nconsole.log(`Existing assignments found: ${existingAssignments.length}`);\nconsole.log(`Documents already processed: ${processedDocIds.size}`);\n\n// Get allDocumentIds from staticData or earlier node\nlet allDocumentIds = staticData.allDocumentIds;\nif (!allDocumentIds || allDocumentIds.length === 0) {\n  try {\n    const collectNode = $('Collect Doc IDs').first().json;\n    allDocumentIds = collectNode.documentIds || [];\n    console.log(`Got ${allDocumentIds.length} document IDs from Collect Doc IDs node`);\n  } catch (e) {\n    console.log(`Could not get from Collect Doc IDs: ${e.message}`);\n    allDocumentIds = [];\n  }\n}\n\nif (!allDocumentIds || allDocumentIds.length === 0) {\n  console.log('No document IDs found - nothing to process');\n  return [{\n    json: {\n      status: 'skipped',\n      reason: 'no_documents_found',\n      processedCount: 0\n    }\n  }];\n}\n\n// Get dimensions from staticData (set by Extract Dimensions node)\nlet dimensions = staticData.dimensions || [];\nlet dimensionList = '';\n\nif (dimensions.length === 0) {\n  // Try to get from Extract Dimensions node\n  try {\n    const extractNode = $('Extract Dimensions').first().json;\n    dimensions = extractNode.dimensions || [];\n    console.log(`Got ${dimensions.length} dimensions from Extract Dimensions node`);\n    // Store for consistency\n    staticData.dimensions = dimensions;\n  } catch (e) {\n    console.log(`Could not get dimensions: ${e.message}`);\n  }\n}\n\n// Build dimension list string for the categorization prompt\nif (dimensions.length > 0) {\n  dimensionList = dimensions.map(d => \n    `- ${d.key}: ${d.name}${d.description ? ' - ' + d.description : ''}`\n  ).join('\\n');\n  console.log(`Dimensions ready: ${dimensions.length}`);\n} else {\n  console.log('WARNING: No dimensions found - categorization will fail!');\n}\n\n// Filter to unprocessed documents\nconst unprocessedDocIds = allDocumentIds.filter(id => !processedDocIds.has(id));\n\nconsole.log(`Documents to categorize: ${unprocessedDocIds.length}`);\n\nif (unprocessedDocIds.length === 0) {\n  console.log('All documents already categorized - nothing to do');\n  return [{\n    json: {\n      status: 'skipped',\n      reason: 'all_documents_already_categorized',\n      processedCount: 0\n    }\n  }];\n}\n\n// Store in staticData for later use\nstaticData.allDocumentIds = allDocumentIds;\nstaticData.versionId = staticData.versionId || $('Collect Doc IDs').first().json.versionId;\n\n// Return list of documents to process WITH dimensions included\nreturn unprocessedDocIds.map(docId => ({\n  json: {\n    documentId: docId,\n    versionId: staticData.versionId,\n    assessmentId: staticData.assessmentId,\n    // Include dimensions for the sub-workflow\n    dimensions: dimensions,\n    dimensionList: dimensionList\n  }\n}));"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-704,32],"id":"e36077b2-d9f6-49d0-8e18-e580cf9eb3ce","name":"Filter Unprocessed"},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"leftValue":"={{ $json.status }}","rightValue":"skipped","operator":{"type":"string","operation":"equals"},"id":"3931e3e1-00bd-4b69-84c5-3f807617b9e0"}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-464,32],"id":"46adacb4-523d-495e-a626-18ba781f57c3","name":"Check Skip"},{"parameters":{"batchSize":20,"options":{"reset":false}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[-224,128],"id":"cb765ad0-4df6-42d4-97ff-8a23c9db72f3","name":"Loop Documents"},{"parameters":{"jsCode":"// All documents already categorized - return skip status\nconst input = $input.first().json;\n\nconsole.log('All documents already categorized - skipping workflow');\n\nreturn [{\n  json: {\n    status: 'skipped',\n    reason: input.reason || 'all_documents_already_categorized',\n    documentsProcessed: 0\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-176,-304],"id":"65de5afe-a32c-4207-91c5-2e9134bb36bf","name":"Skip Output"},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"leftValue":"={{ $json._skipFetch }}","rightValue":true,"operator":{"type":"boolean","operation":"equals"},"id":"bda09ad2-f6ed-4e7d-b654-8c086962e610"}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-2672,32],"id":"1c037924-515a-4ee2-945d-1cfc7d4fcd2f","name":"Skip Fetch?"},{"parameters":{"operation":"get","tableId":"playbook_industry_variants","filters":{"conditions":[{"keyName":"id","keyValue":"={{ $json.playbook_variant_id }}"}]}},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-2144,128],"id":"86e11862-602a-46a8-931d-559170b738a7","name":"Get Variant","credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"operation":"get","tableId":"playbooks"},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-2144,336],"id":"55bdb951-394b-4590-a248-087fafc83301","name":"Get Base Playbook","credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"leftValue":"={{ $json._source }}","rightValue":"variant","operator":{"type":"string","operation":"equals"},"id":"b146d98b-02b2-40ed-b813-65381cc5ee45"}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-2384,176],"id":"6829e30d-16e4-4490-ae57-639225d3aa5b","name":"Use Variant?"},{"parameters":{"workflowId":{"__rl":true,"value":"anphyr0Am3ub4IiA","mode":"list","cachedResultUrl":"/workflow/anphyr0Am3ub4IiA","cachedResultName":"Parallel Processor document Categorizer ANK"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"mode":"each","options":{"waitForSubWorkflow":false}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.2,"position":[688,160],"name":"Call Parallel Processor document Categorizer","id":"83db2766-bd52-460d-94c4-afa5ad0f9c80"},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"leftValue":"={{ $json.skip }}","rightValue":true,"operator":{"type":"boolean","operation":"equals"},"id":"da345f11-16be-4f39-84cc-081f541e9bd7"}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[1936,-64],"id":"185e2ac9-2345-4cbc-a793-cb53e1dc4c57","name":"Check Skip Analysis1"},{"parameters":{"jsCode":"// Output when analysis was skipped\nconst input = $input.first().json;\n\nreturn [{\n  json: {\n    status: 'skipped',\n    reason: input.reason,\n    assessmentId: input.assessmentId,\n    versionId: input.versionId,\n    readyForReport: false,\n    completedAt: new Date().toISOString()\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2176,-144],"id":"168b8b93-7856-40e3-8300-53abb8166f91","name":"Skip Analysis Output1"},{"parameters":{"jsCode":"// SMART WAIT - Calculate expected time for async categorization\nconst staticData = $getWorkflowStaticData('global');\nconst expectedDocCount = staticData.allDocumentIds?.length || 0;\nconst versionId = staticData.versionId;\nconst assessmentId = staticData.assessmentId;\n\nif (expectedDocCount === 0) {\n  console.log('No documents to categorize - skipping wait');\n  return [{\n    json: {\n      status: 'skipped',\n      reason: 'no_documents',\n      assessmentId: assessmentId,\n      versionId: versionId,\n      dimensions: staticData.dimensions\n    }\n  }];\n}\n\n// SMART CALCULATION:\n// With Haiku + 12K tokens + async execution:\n// - Small docs (<5K tokens): ~3-5 seconds\n// - Medium docs (5-10K tokens): ~5-8 seconds  \n// - Large docs (10-12K tokens): ~8-12 seconds\n// - Average: ~6 seconds per doc\n// - Batch of 20 processes in parallel\n\nconst batchSize = 20;\nconst avgSecondsPerDoc = 6;\n\n// Calculate batches\nconst numBatches = Math.ceil(expectedDocCount / batchSize);\n\n// Time = (number of batches) * (avg time per doc) + buffer\nconst estimatedSeconds = numBatches * avgSecondsPerDoc;\nconst bufferSeconds = 10; // Extra safety buffer\nconst totalWaitSeconds = estimatedSeconds + bufferSeconds;\n\nconsole.log(`‚è≥ Smart Wait Calculation:`);\nconsole.log(`   Documents: ${expectedDocCount}`);\nconsole.log(`   Batches: ${numBatches} (batch size: ${batchSize})`);\nconsole.log(`   Estimated time: ${estimatedSeconds}s + ${bufferSeconds}s buffer = ${totalWaitSeconds}s`);\nconsole.log(`   Waiting ${totalWaitSeconds} seconds for categorization to complete...`);\n\n// Wait the calculated time\nawait new Promise(resolve => setTimeout(resolve, totalWaitSeconds * 1000));\n\nconsole.log(`‚úÖ Wait complete! Verifying categorization status...`);\n\nreturn [{\n  json: {\n    status: 'wait_complete',\n    documentsProcessed: expectedDocCount,\n    waitTime: totalWaitSeconds,\n    assessmentId: assessmentId,\n    versionId: versionId,\n    dimensions: staticData.dimensions\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-32,-64],"id":"50c84615-a9cc-4295-a755-22dec8f03618","name":"Wait for Categorization Complete"},{"parameters":{"jsCode":"// Get assessment info and split into one item per dimension\nconst staticData = $getWorkflowStaticData('global');\nconst results = $input.all().map(i => i.json);\n\nconst assessmentId = staticData.assessmentId || results[0]?.assessment_id;\nconst versionId = staticData.versionId || results[0]?.version_id;\nconst dimensions = staticData.dimensions || [];\n\nif (dimensions.length === 0) {\n  return [{\n    json: {\n      skip: true,\n      reason: 'no_dimensions_found'\n    }\n  }];\n}\n\n// Return ONE ITEM PER DIMENSION\nreturn dimensions.map((dim, index) => ({\n  json: {\n    assessmentId: assessmentId,\n    versionId: versionId,\n    dimensionKey: dim.key,\n    dimensionName: dim.name,\n    dimensionWeight: dim.weight,\n    dimensionOrder: index + 1,\n    totalDimensions: dimensions.length\n  }\n}));"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[960,-64],"id":"1bbeafe4-3c15-4993-9923-e60ca8ae10b2","name":"Code in JavaScript"},{"parameters":{"operation":"getAll","tableId":"document_dimension_assignments","returnAll":true,"filterType":"string","filterString":"=version_id=eq.{{ $('Wait for Categorization Complete').first().json.versionId }}"},"id":"a20a065b-73bf-4f41-bc32-6e9e0ac610e7","name":"Check Completion Status","type":"n8n-nodes-base.supabase","typeVersion":1,"position":[256,-80],"credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"jsCode":"// Verify all documents have been categorized\nconst assignments = $input.all().map(item => item.json);\nconst waitData = $('Wait for Categorization Complete').first().json;\nconst expectedDocCount = waitData.documentsProcessed;\n\n// Count unique documents that have been categorized\nconst categorizedDocs = new Set(assignments.map(a => a.document_id));\nconst categorizedCount = categorizedDocs.size;\n\nconsole.log(`üìä Verification: ${categorizedCount}/${expectedDocCount} documents categorized`);\nconsole.log(`üìä Total assignments: ${assignments.length}`);\n\n// Check if we're done\nconst isComplete = categorizedCount >= expectedDocCount;\n\nif (isComplete) {\n  console.log(`‚úÖ All ${expectedDocCount} documents successfully categorized!`);\n} else {\n  console.log(`‚ö†Ô∏è Only ${categorizedCount}/${expectedDocCount} documents categorized`);\n}\n\nreturn [{\n  json: {\n    status: isComplete ? 'complete' : 'incomplete',\n    categorizedCount: categorizedCount,\n    expectedCount: expectedDocCount,\n    totalAssignments: assignments.length,\n    assessmentId: waitData.assessmentId,\n    versionId: waitData.versionId,\n    dimensions: waitData.dimensions,\n    completedAt: new Date().toISOString()\n  }\n}];"},"id":"594402b3-12ba-458f-bf56-9c5c9ca93109","name":"Verify All Categorized","type":"n8n-nodes-base.code","typeVersion":1,"position":[480,-64]},{"parameters":{"amount":30},"type":"n8n-nodes-base.wait","typeVersion":1.1,"position":[960,176],"id":"762eb556-fc2d-4953-ab91-2a668a35c536","name":"Wait","webhookId":"5691a7e3-a1a7-4857-a241-f6887b1573eb"},{"parameters":{"workflowId":{"__rl":true,"value":"4Zu1k5LxauFl7crW","mode":"list","cachedResultUrl":"/workflow/4Zu1k5LxauFl7crW","cachedResultName":"Phase 2 - Dimension Analysis (Document-Based) v3 ANK"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"mode":"each","options":{"waitForSubWorkflow":false}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.3,"position":[2144,144],"id":"f325e0de-b362-4031-a854-a03634eb15da","name":"Call 'Phase 2 - Dimension Analysis (Document-Based) v3 ANK'"}],"connections":{"From Document Processor":{"main":[[{"node":"Initialize","type":"main","index":0}]]},"Initialize":{"main":[[{"node":"Get Assessment","type":"main","index":0}]]},"Get Assessment":{"main":[[{"node":"Check Variant","type":"main","index":0}]]},"Check Variant":{"main":[[{"node":"Skip Fetch?","type":"main","index":0}]]},"Skip Fetch?":{"main":[[{"node":"Extract Dimensions","type":"main","index":0}],[{"node":"Use Variant?","type":"main","index":0}]]},"Use Variant?":{"main":[[{"node":"Get Variant","type":"main","index":0}],[{"node":"Get Base Playbook","type":"main","index":0}]]},"Get Variant":{"main":[[{"node":"Extract Dimensions","type":"main","index":0}]]},"Extract Dimensions":{"main":[[{"node":"Get Documents","type":"main","index":0}]]},"Get Documents":{"main":[[{"node":"Collect Doc IDs","type":"main","index":0}]]},"Collect Doc IDs":{"main":[[{"node":"Get Existing Assignments","type":"main","index":0}]]},"Get Existing Assignments":{"main":[[{"node":"Filter Unprocessed","type":"main","index":0}]]},"Filter Unprocessed":{"main":[[{"node":"Check Skip","type":"main","index":0}]]},"Check Skip":{"main":[[{"node":"Skip Output","type":"main","index":0}],[{"node":"Loop Documents","type":"main","index":0}]]},"Loop Documents":{"main":[[{"node":"Wait for Categorization Complete","type":"main","index":0}],[{"node":"Call Parallel Processor document Categorizer","type":"main","index":0}]]},"Get Base Playbook":{"main":[[{"node":"Extract Dimensions","type":"main","index":0}]]},"Check Skip Analysis1":{"main":[[{"node":"Skip Analysis Output1","type":"main","index":0}],[{"node":"Call 'Phase 2 - Dimension Analysis (Document-Based) v3 ANK'","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Check Skip Analysis1","type":"main","index":0}]]},"Wait for Categorization Complete":{"main":[[{"node":"Check Completion Status","type":"main","index":0}]]},"Check Completion Status":{"main":[[{"node":"Verify All Categorized","type":"main","index":0}]]},"Verify All Categorized":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Call Parallel Processor document Categorizer":{"main":[[{"node":"Wait","type":"main","index":0}]]},"Wait":{"main":[[{"node":"Loop Documents","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","availableInMCP":false,"callerPolicy":"workflowsFromSameOwner"},"staticData":{"global":{"processedDocuments":[],"assessmentId":"a0dc498d-9411-49f0-9359-c5989f4acabc","versionId":"75e813b5-98f7-4afd-babd-d288fdfdb0d1","documents":[],"dimensions":[{"key":"people_org","name":"People & Organizational Readiness","weight":0.17,"description":"Assessment of people & organizational readiness capabilities and maturity for B2B Global Sourcing & Procurement Services"},{"key":"data_analytics","name":"Data Infrastructure & Analytics","weight":0.17,"description":"Assessment of data infrastructure & analytics capabilities and maturity for B2B Global Sourcing & Procurement Services"},{"key":"technology","name":"Technology Stack & Integration","weight":0.17,"description":"Assessment of technology stack & integration capabilities and maturity for B2B Global Sourcing & Procurement Services"},{"key":"commercial","name":"Commercial Strategy & Market Approach","weight":0.17,"description":"Assessment of commercial strategy & market approach capabilities and maturity for B2B Global Sourcing & Procurement Services"},{"key":"operations","name":"Operations & Process Excellence","weight":0.16,"description":"Assessment of operations & process excellence capabilities and maturity for B2B Global Sourcing & Procurement Services"},{"key":"financial","name":"Financial Operations & Business Model","weight":0.16,"description":"Assessment of financial operations & business model capabilities and maturity for B2B Global Sourcing & Procurement Services"}],"playbookName":"GTM AI Readiness Assessment - B2B Global Sourcing & Procurement Services (Buying Office)","playbookType":"gtm_readiness","hasVariant":true,"allDocumentIds":["8e628e9c-01ff-49d3-9010-37ace4c569cf","a9955ae9-b0ae-4200-bb24-5343944c3b4d","21c0c154-3b88-4a92-906c-7d5b42292346","75790323-bb49-4819-b8ca-362aa902067a","7528269c-61c2-448d-a984-b3e918ea6f45","aeaffcaf-d9d4-4c34-9d91-4168c1066a06","72462a3d-3417-496b-90d3-b2d21a7327d3","8b6378c4-bdcb-4afb-acf4-1401020039a7","9b5bc5b3-555a-44b0-ac21-9c062dda09e4","db1bae71-7ca6-4768-a0c4-81e3ed7edb9a","4a1fecd2-52b7-4fde-9931-811ead45c1af","c5e1f18b-a6c5-49bf-97e3-94cf39b3bebb","b9ed37fe-ab68-42b6-8141-118651573d66","475c6c3e-8afd-4b15-9b1a-803c290f82c8","10c7f702-7d13-4161-84ad-11f4ed80fff4","f409331e-3e10-4d36-ab16-b4e1a22801f2","6e7381ec-9fa4-45f3-8ac2-45d6252e2bd1","3e9078e4-7c9f-45b6-9cc1-9321264a171b","bd7dd13e-d8f7-4ee6-8bf8-c695e94db795","8cb2a5e8-7000-4349-a921-0d3c774e6cff","d007d9ac-dbfc-41d1-9421-f4d09413ff2e","2e0fb139-50b9-4b2c-95a8-e8316da28069","3aa2ea6c-d293-4b35-9530-6daddc5477f7"],"organizationId":"61baaeb3-c33e-49cd-ac56-7dbc59f99699"}},"meta":{"templateCredsSetupCompleted":true},"pinData":{"From Document Processor":[{"json":{"assessmentId":"a0dc498d-9411-49f0-9359-c5989f4acabc","versionId":"75e813b5-98f7-4afd-babd-d288fdfdb0d1","stage":"strategic","iteration":1,"organizationId":"61baaeb3-c33e-49cd-ac56-7dbc59f99699","totalDocuments":23,"successfulDocuments":21,"failedDocuments":2,"successRate":"91.3%","processingStartedAt":"2026-02-12T13:02:07.502Z","processingCompletedAt":"2026-02-12T13:05:34.977Z","categorization":{"id":"091bab51-859f-497e-829f-86b6521d8ecd","organization_id":"61baaeb3-c33e-49cd-ac56-7dbc59f99699","assessment_id":"a0dc498d-9411-49f0-9359-c5989f4acabc","version_id":"75e813b5-98f7-4afd-babd-d288fdfdb0d1","document_id":"8e628e9c-01ff-49d3-9010-37ace4c569cf","chunk_index":0,"total_chunks":1,"content_text":"Monthly SO vs Budget-By Trading Team-Sales Print at: 2/6/2026 11:13:08 AM","char_count":75,"token_count":19,"page_range":null,"slide_range":null,"row_range":null,"sheet_name":null,"processing_status":"pending","created_at":"2026-02-12T13:05:34.750789+00:00","processed_at":null,"deleted_at":null},"errors":[{"fileName":"Client Satisfaction Survey 2025-30 responses 1.pdf","fileType":"pdf","error":"INVALID_ELEMENT","errorMessage":"Element missing type or text. Keys: type, element_id, text, metadata","timestamp":"2026-02-12T13:02:35.850Z"},{"fileName":"ET2C Quotation Format_Industrial.pdf","fileType":"pdf","error":"INVALID_ELEMENT","errorMessage":"Element missing type or text. Keys: type, element_id, text, metadata","timestamp":"2026-02-12T13:03:29.181Z"}],"status":"completed_with_errors","message":"Processed 21/23 documents. 2 failed."},"pairedItem":{"item":0}}]},"versionId":"0e50e0c0-7b7d-4d3d-87b0-2199a1779f0f","activeVersionId":"0e50e0c0-7b7d-4d3d-87b0-2199a1779f0f","versionCounter":91,"triggerCount":0,"shared":[{"updatedAt":"2026-02-19T12:30:26.342Z","createdAt":"2026-02-19T12:30:26.342Z","role":"workflow:owner","workflowId":"1ynOLUqzJRBweKUj","projectId":"DVYglwqlfMJuM9zT","project":{"updatedAt":"2025-10-05T18:15:43.115Z","createdAt":"2025-08-13T20:40:27.041Z","id":"DVYglwqlfMJuM9zT","name":"Laksh Agrawal <laksh@supastack.ai>","type":"personal","icon":null,"description":null,"creatorId":"ec164287-6cde-4606-b0c4-9d4cd30c3b98","projectRelations":[{"updatedAt":"2025-08-13T20:40:27.041Z","createdAt":"2025-08-13T20:40:27.041Z","userId":"ec164287-6cde-4606-b0c4-9d4cd30c3b98","projectId":"DVYglwqlfMJuM9zT","user":{"updatedAt":"2026-02-22T00:41:30.000Z","createdAt":"2025-08-13T20:40:26.693Z","id":"ec164287-6cde-4606-b0c4-9d4cd30c3b98","email":"laksh@supastack.ai","firstName":"Laksh","lastName":"Agrawal","personalizationAnswers":{"version":"v4","personalization_survey_submitted_at":"2025-08-13T20:49:45.872Z","personalization_survey_n8n_version":"1.106.3","companyIndustryExtended":[],"companyType":"other"},"settings":{"userActivated":true,"easyAIWorkflowOnboarded":true,"firstSuccessfulWorkflowId":"omMzGXpD7rLUfAFm","userActivatedAt":1755124587490,"npsSurvey":{"responded":true,"lastShownAt":1759741367883}},"disabled":false,"mfaEnabled":false,"lastActiveAt":"2026-02-21","isPending":false}}]}}],"tags":[],"activeVersion":{"updatedAt":"2026-02-22T01:00:14.000Z","createdAt":"2026-02-22T01:00:10.482Z","versionId":"0e50e0c0-7b7d-4d3d-87b0-2199a1779f0f","workflowId":"1ynOLUqzJRBweKUj","nodes":[{"parameters":{"inputSource":"passthrough"},"type":"n8n-nodes-base.executeWorkflowTrigger","typeVersion":1.1,"position":[-3472,32],"id":"1d972686-f4ec-42eb-9c1d-4abee9e7c86a","name":"From Document Processor"},{"parameters":{"jsCode":"// Initialize workflow with input from Document Processor\nconst staticData = $getWorkflowStaticData('global');\nconst input = $input.first().json;\n\n// Store IDs\nstaticData.assessmentId = input.assessmentId;\nstaticData.versionId = input.versionId;\nstaticData.organizationId = input.organizationId;\nstaticData.documents = input.documents || [];\n\nconsole.log(`Document Categorizer initialized`);\nconsole.log(`Assessment: ${staticData.assessmentId}`);\nconsole.log(`Version: ${staticData.versionId}`);\nconsole.log(`Documents to categorize: ${staticData.documents.length}`);\n\nreturn [{\n  json: {\n    assessmentId: staticData.assessmentId,\n    versionId: staticData.versionId\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-3200,32],"id":"ac646a79-64fa-47c0-a1bc-34f9ee78f395","name":"Initialize"},{"parameters":{"operation":"get","tableId":"assessments","filters":{"conditions":[{"keyName":"id","keyValue":"={{ $json.assessmentId }}"}]}},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-3024,32],"id":"e2b96b72-f07b-4e67-be1b-caf1c7be9ef3","name":"Get Assessment","credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"jsCode":"// Check if we should use variant or base playbook\nconst assessment = $input.first().json;\n\nconst hasVariant = !!assessment.playbook_variant_id;\nconst hasCachedContent = !!assessment.playbook_content;\n\nconsole.log(`Assessment: ${assessment.id}`);\nconsole.log(`Has variant: ${hasVariant}`);\nconsole.log(`Has cached content: ${hasCachedContent}`);\n\n// If content is cached on assessment, we can skip fetching playbook\nif (hasCachedContent) {\n  return [{\n    json: {\n      ...assessment,\n      _source: 'cached',\n      _skipFetch: true\n    }\n  }];\n}\n\n// Otherwise, return with routing info\nreturn [{\n  json: {\n    ...assessment,\n    _source: hasVariant ? 'variant' : 'base',\n    _skipFetch: false,\n    _fetchId: hasVariant ? assessment.playbook_variant_id : assessment.playbook_id\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2848,32],"id":"78991078-800d-4e8b-9523-a14f92ede66b","name":"Check Variant"},{"parameters":{"jsCode":"// Extract dimensions from playbook (variant or base)\nconst staticData = $getWorkflowStaticData('global');\nconst assessment = $('Get Assessment').first().json;\n\n// Check which playbook source we have\nconst hasVariant = !!assessment.playbook_variant_id;\nconst playbookContent = assessment.playbook_content; // Cached on assessment\n\nlet dimensions = [];\nlet playbookName = '';\nlet playbookType = '';\n\n// If playbook_content is cached on assessment, use it directly\nif (playbookContent) {\n  let content = playbookContent;\n  if (typeof content === 'string') {\n    content = JSON.parse(content);\n  }\n  dimensions = content.dimensions || [];\n  playbookName = content.metadata?.name || 'Cached Playbook';\n  playbookType = content.metadata?.playbook_type || assessment.assessment_type;\n  console.log('Using cached playbook_content from assessment');\n} else {\n  // Otherwise use the input from Get Playbook/Variant node\n  const playbook = $input.first().json;\n  let content = playbook.content;\n  if (typeof content === 'string') {\n    content = JSON.parse(content);\n  }\n  dimensions = content.dimensions || [];\n  playbookName = playbook.name || playbook.variant_name || 'Unknown';\n  playbookType = playbook.playbook_type || assessment.assessment_type;\n}\n\n// Store dimensions in static data\nstaticData.dimensions = dimensions.map(d => ({\n  key: d.key || d.dimension_key,\n  name: d.name || d.dimension_name,\n  weight: d.weight || d.dimension_weight,\n  description: d.description || ''\n}));\n\nstaticData.playbookName = playbookName;\nstaticData.playbookType = playbookType;\nstaticData.hasVariant = hasVariant;\n\nconsole.log(`Playbook: ${playbookName} (variant: ${hasVariant})`);\nconsole.log(`Dimensions found: ${staticData.dimensions.length}`);\nstaticData.dimensions.forEach(d => {\n  console.log(`  - ${d.key}: ${d.name}`);\n});\n\nreturn [{\n  json: {\n    assessmentId: staticData.assessmentId,\n    versionId: staticData.versionId,\n    playbookName: playbookName,\n    hasVariant: hasVariant,\n    dimensionCount: staticData.dimensions.length,\n    dimensions: staticData.dimensions\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-1664,32],"id":"f8eedf17-a7cd-4f68-b22e-2bd9b2410d9f","name":"Extract Dimensions"},{"parameters":{"operation":"getAll","tableId":"document_metadata","returnAll":true,"filters":{"conditions":[{"keyName":"version_id","condition":"eq","keyValue":"={{ $('From Document Processor').first().json.versionId }}"}]}},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-1424,32],"id":"3150008c-91b6-48e4-8d7d-679cc13bbaab","name":"Get Documents","credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"jsCode":"// Filter out documents that already have dimension assignments\nconst staticData = $getWorkflowStaticData('global');\nconst documents = $input.all().map(item => item.json);\n\nconsole.log(`Found ${documents.length} documents for this version`);\n\n// Store document IDs for checking existing assignments\nconst documentIds = documents.map(d => d.id);\nstaticData.allDocumentIds = documentIds;\n\n// Pass through to check existing assignments\nreturn [{\n  json: {\n    documentIds: documentIds,\n    versionId: staticData.versionId,\n    documentCount: documents.length\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-1184,32],"id":"8ae79f6e-cce0-451b-9bdf-c9be440eda84","name":"Collect Doc IDs"},{"parameters":{"operation":"getAll","tableId":"document_dimension_assignments","returnAll":true,"filterType":"string","filterString":"=version_id=eq.{{ $('From Document Processor').first().json.versionId }}"},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-944,32],"id":"aeca0f8c-4bd9-4ddf-b939-5c33e975d0f4","name":"Get Existing Assignments","executeOnce":false,"alwaysOutputData":true,"credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}},"onError":"continueRegularOutput"},{"parameters":{"jsCode":"// Filter to only unprocessed documents AND include dimensions\nconst staticData = $getWorkflowStaticData('global');\nconst existingAssignments = $input.all().map(item => item.json).filter(item => item.document_id);\n\n// Get unique document IDs that already have assignments\nconst processedDocIds = new Set(existingAssignments.map(a => a.document_id));\n\nconsole.log(`Existing assignments found: ${existingAssignments.length}`);\nconsole.log(`Documents already processed: ${processedDocIds.size}`);\n\n// Get allDocumentIds from staticData or earlier node\nlet allDocumentIds = staticData.allDocumentIds;\nif (!allDocumentIds || allDocumentIds.length === 0) {\n  try {\n    const collectNode = $('Collect Doc IDs').first().json;\n    allDocumentIds = collectNode.documentIds || [];\n    console.log(`Got ${allDocumentIds.length} document IDs from Collect Doc IDs node`);\n  } catch (e) {\n    console.log(`Could not get from Collect Doc IDs: ${e.message}`);\n    allDocumentIds = [];\n  }\n}\n\nif (!allDocumentIds || allDocumentIds.length === 0) {\n  console.log('No document IDs found - nothing to process');\n  return [{\n    json: {\n      status: 'skipped',\n      reason: 'no_documents_found',\n      processedCount: 0\n    }\n  }];\n}\n\n// Get dimensions from staticData (set by Extract Dimensions node)\nlet dimensions = staticData.dimensions || [];\nlet dimensionList = '';\n\nif (dimensions.length === 0) {\n  // Try to get from Extract Dimensions node\n  try {\n    const extractNode = $('Extract Dimensions').first().json;\n    dimensions = extractNode.dimensions || [];\n    console.log(`Got ${dimensions.length} dimensions from Extract Dimensions node`);\n    // Store for consistency\n    staticData.dimensions = dimensions;\n  } catch (e) {\n    console.log(`Could not get dimensions: ${e.message}`);\n  }\n}\n\n// Build dimension list string for the categorization prompt\nif (dimensions.length > 0) {\n  dimensionList = dimensions.map(d => \n    `- ${d.key}: ${d.name}${d.description ? ' - ' + d.description : ''}`\n  ).join('\\n');\n  console.log(`Dimensions ready: ${dimensions.length}`);\n} else {\n  console.log('WARNING: No dimensions found - categorization will fail!');\n}\n\n// Filter to unprocessed documents\nconst unprocessedDocIds = allDocumentIds.filter(id => !processedDocIds.has(id));\n\nconsole.log(`Documents to categorize: ${unprocessedDocIds.length}`);\n\nif (unprocessedDocIds.length === 0) {\n  console.log('All documents already categorized - nothing to do');\n  return [{\n    json: {\n      status: 'skipped',\n      reason: 'all_documents_already_categorized',\n      processedCount: 0\n    }\n  }];\n}\n\n// Store in staticData for later use\nstaticData.allDocumentIds = allDocumentIds;\nstaticData.versionId = staticData.versionId || $('Collect Doc IDs').first().json.versionId;\n\n// Return list of documents to process WITH dimensions included\nreturn unprocessedDocIds.map(docId => ({\n  json: {\n    documentId: docId,\n    versionId: staticData.versionId,\n    assessmentId: staticData.assessmentId,\n    // Include dimensions for the sub-workflow\n    dimensions: dimensions,\n    dimensionList: dimensionList\n  }\n}));"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-704,32],"id":"e36077b2-d9f6-49d0-8e18-e580cf9eb3ce","name":"Filter Unprocessed"},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"leftValue":"={{ $json.status }}","rightValue":"skipped","operator":{"type":"string","operation":"equals"},"id":"3931e3e1-00bd-4b69-84c5-3f807617b9e0"}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-464,32],"id":"46adacb4-523d-495e-a626-18ba781f57c3","name":"Check Skip"},{"parameters":{"batchSize":20,"options":{"reset":false}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[-224,128],"id":"cb765ad0-4df6-42d4-97ff-8a23c9db72f3","name":"Loop Documents"},{"parameters":{"jsCode":"// All documents already categorized - return skip status\nconst input = $input.first().json;\n\nconsole.log('All documents already categorized - skipping workflow');\n\nreturn [{\n  json: {\n    status: 'skipped',\n    reason: input.reason || 'all_documents_already_categorized',\n    documentsProcessed: 0\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-176,-304],"id":"65de5afe-a32c-4207-91c5-2e9134bb36bf","name":"Skip Output"},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"leftValue":"={{ $json._skipFetch }}","rightValue":true,"operator":{"type":"boolean","operation":"equals"},"id":"bda09ad2-f6ed-4e7d-b654-8c086962e610"}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-2672,32],"id":"1c037924-515a-4ee2-945d-1cfc7d4fcd2f","name":"Skip Fetch?"},{"parameters":{"operation":"get","tableId":"playbook_industry_variants","filters":{"conditions":[{"keyName":"id","keyValue":"={{ $json.playbook_variant_id }}"}]}},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-2144,128],"id":"86e11862-602a-46a8-931d-559170b738a7","name":"Get Variant","credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"operation":"get","tableId":"playbooks"},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[-2144,336],"id":"55bdb951-394b-4590-a248-087fafc83301","name":"Get Base Playbook","credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"leftValue":"={{ $json._source }}","rightValue":"variant","operator":{"type":"string","operation":"equals"},"id":"b146d98b-02b2-40ed-b813-65381cc5ee45"}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-2384,176],"id":"6829e30d-16e4-4490-ae57-639225d3aa5b","name":"Use Variant?"},{"parameters":{"workflowId":{"__rl":true,"value":"anphyr0Am3ub4IiA","mode":"list","cachedResultUrl":"/workflow/anphyr0Am3ub4IiA","cachedResultName":"Parallel Processor document Categorizer ANK"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"mode":"each","options":{"waitForSubWorkflow":false}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.2,"position":[688,160],"name":"Call Parallel Processor document Categorizer","id":"83db2766-bd52-460d-94c4-afa5ad0f9c80"},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"leftValue":"={{ $json.skip }}","rightValue":true,"operator":{"type":"boolean","operation":"equals"},"id":"da345f11-16be-4f39-84cc-081f541e9bd7"}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[1936,-64],"id":"185e2ac9-2345-4cbc-a793-cb53e1dc4c57","name":"Check Skip Analysis1"},{"parameters":{"jsCode":"// Output when analysis was skipped\nconst input = $input.first().json;\n\nreturn [{\n  json: {\n    status: 'skipped',\n    reason: input.reason,\n    assessmentId: input.assessmentId,\n    versionId: input.versionId,\n    readyForReport: false,\n    completedAt: new Date().toISOString()\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2176,-144],"id":"168b8b93-7856-40e3-8300-53abb8166f91","name":"Skip Analysis Output1"},{"parameters":{"jsCode":"// SMART WAIT - Calculate expected time for async categorization\nconst staticData = $getWorkflowStaticData('global');\nconst expectedDocCount = staticData.allDocumentIds?.length || 0;\nconst versionId = staticData.versionId;\nconst assessmentId = staticData.assessmentId;\n\nif (expectedDocCount === 0) {\n  console.log('No documents to categorize - skipping wait');\n  return [{\n    json: {\n      status: 'skipped',\n      reason: 'no_documents',\n      assessmentId: assessmentId,\n      versionId: versionId,\n      dimensions: staticData.dimensions\n    }\n  }];\n}\n\n// SMART CALCULATION:\n// With Haiku + 12K tokens + async execution:\n// - Small docs (<5K tokens): ~3-5 seconds\n// - Medium docs (5-10K tokens): ~5-8 seconds  \n// - Large docs (10-12K tokens): ~8-12 seconds\n// - Average: ~6 seconds per doc\n// - Batch of 20 processes in parallel\n\nconst batchSize = 20;\nconst avgSecondsPerDoc = 6;\n\n// Calculate batches\nconst numBatches = Math.ceil(expectedDocCount / batchSize);\n\n// Time = (number of batches) * (avg time per doc) + buffer\nconst estimatedSeconds = numBatches * avgSecondsPerDoc;\nconst bufferSeconds = 10; // Extra safety buffer\nconst totalWaitSeconds = estimatedSeconds + bufferSeconds;\n\nconsole.log(`‚è≥ Smart Wait Calculation:`);\nconsole.log(`   Documents: ${expectedDocCount}`);\nconsole.log(`   Batches: ${numBatches} (batch size: ${batchSize})`);\nconsole.log(`   Estimated time: ${estimatedSeconds}s + ${bufferSeconds}s buffer = ${totalWaitSeconds}s`);\nconsole.log(`   Waiting ${totalWaitSeconds} seconds for categorization to complete...`);\n\n// Wait the calculated time\nawait new Promise(resolve => setTimeout(resolve, totalWaitSeconds * 1000));\n\nconsole.log(`‚úÖ Wait complete! Verifying categorization status...`);\n\nreturn [{\n  json: {\n    status: 'wait_complete',\n    documentsProcessed: expectedDocCount,\n    waitTime: totalWaitSeconds,\n    assessmentId: assessmentId,\n    versionId: versionId,\n    dimensions: staticData.dimensions\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-32,-64],"id":"50c84615-a9cc-4295-a755-22dec8f03618","name":"Wait for Categorization Complete"},{"parameters":{"jsCode":"// Get assessment info and split into one item per dimension\nconst staticData = $getWorkflowStaticData('global');\nconst results = $input.all().map(i => i.json);\n\nconst assessmentId = staticData.assessmentId || results[0]?.assessment_id;\nconst versionId = staticData.versionId || results[0]?.version_id;\nconst dimensions = staticData.dimensions || [];\n\nif (dimensions.length === 0) {\n  return [{\n    json: {\n      skip: true,\n      reason: 'no_dimensions_found'\n    }\n  }];\n}\n\n// Return ONE ITEM PER DIMENSION\nreturn dimensions.map((dim, index) => ({\n  json: {\n    assessmentId: assessmentId,\n    versionId: versionId,\n    dimensionKey: dim.key,\n    dimensionName: dim.name,\n    dimensionWeight: dim.weight,\n    dimensionOrder: index + 1,\n    totalDimensions: dimensions.length\n  }\n}));"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[960,-64],"id":"1bbeafe4-3c15-4993-9923-e60ca8ae10b2","name":"Code in JavaScript"},{"parameters":{"operation":"getAll","tableId":"document_dimension_assignments","returnAll":true,"filterType":"string","filterString":"=version_id=eq.{{ $('Wait for Categorization Complete').first().json.versionId }}"},"id":"a20a065b-73bf-4f41-bc32-6e9e0ac610e7","name":"Check Completion Status","type":"n8n-nodes-base.supabase","typeVersion":1,"position":[256,-80],"credentials":{"supabaseApi":{"id":"FTSugGkqwnuu6irz","name":"SupaStack"}}},{"parameters":{"jsCode":"// Verify all documents have been categorized\nconst assignments = $input.all().map(item => item.json);\nconst waitData = $('Wait for Categorization Complete').first().json;\nconst expectedDocCount = waitData.documentsProcessed;\n\n// Count unique documents that have been categorized\nconst categorizedDocs = new Set(assignments.map(a => a.document_id));\nconst categorizedCount = categorizedDocs.size;\n\nconsole.log(`üìä Verification: ${categorizedCount}/${expectedDocCount} documents categorized`);\nconsole.log(`üìä Total assignments: ${assignments.length}`);\n\n// Check if we're done\nconst isComplete = categorizedCount >= expectedDocCount;\n\nif (isComplete) {\n  console.log(`‚úÖ All ${expectedDocCount} documents successfully categorized!`);\n} else {\n  console.log(`‚ö†Ô∏è Only ${categorizedCount}/${expectedDocCount} documents categorized`);\n}\n\nreturn [{\n  json: {\n    status: isComplete ? 'complete' : 'incomplete',\n    categorizedCount: categorizedCount,\n    expectedCount: expectedDocCount,\n    totalAssignments: assignments.length,\n    assessmentId: waitData.assessmentId,\n    versionId: waitData.versionId,\n    dimensions: waitData.dimensions,\n    completedAt: new Date().toISOString()\n  }\n}];"},"id":"594402b3-12ba-458f-bf56-9c5c9ca93109","name":"Verify All Categorized","type":"n8n-nodes-base.code","typeVersion":1,"position":[480,-64]},{"parameters":{"amount":30},"type":"n8n-nodes-base.wait","typeVersion":1.1,"position":[960,176],"id":"762eb556-fc2d-4953-ab91-2a668a35c536","name":"Wait","webhookId":"5691a7e3-a1a7-4857-a241-f6887b1573eb"},{"parameters":{"workflowId":{"__rl":true,"value":"4Zu1k5LxauFl7crW","mode":"list","cachedResultUrl":"/workflow/4Zu1k5LxauFl7crW","cachedResultName":"Phase 2 - Dimension Analysis (Document-Based) v3 ANK"},"workflowInputs":{"mappingMode":"defineBelow","value":{},"matchingColumns":[],"schema":[],"attemptToConvertTypes":false,"convertFieldsToString":true},"mode":"each","options":{"waitForSubWorkflow":false}},"type":"n8n-nodes-base.executeWorkflow","typeVersion":1.3,"position":[2144,144],"id":"f325e0de-b362-4031-a854-a03634eb15da","name":"Call 'Phase 2 - Dimension Analysis (Document-Based) v3 ANK'"}],"connections":{"From Document Processor":{"main":[[{"node":"Initialize","type":"main","index":0}]]},"Initialize":{"main":[[{"node":"Get Assessment","type":"main","index":0}]]},"Get Assessment":{"main":[[{"node":"Check Variant","type":"main","index":0}]]},"Check Variant":{"main":[[{"node":"Skip Fetch?","type":"main","index":0}]]},"Skip Fetch?":{"main":[[{"node":"Extract Dimensions","type":"main","index":0}],[{"node":"Use Variant?","type":"main","index":0}]]},"Use Variant?":{"main":[[{"node":"Get Variant","type":"main","index":0}],[{"node":"Get Base Playbook","type":"main","index":0}]]},"Get Variant":{"main":[[{"node":"Extract Dimensions","type":"main","index":0}]]},"Extract Dimensions":{"main":[[{"node":"Get Documents","type":"main","index":0}]]},"Get Documents":{"main":[[{"node":"Collect Doc IDs","type":"main","index":0}]]},"Collect Doc IDs":{"main":[[{"node":"Get Existing Assignments","type":"main","index":0}]]},"Get Existing Assignments":{"main":[[{"node":"Filter Unprocessed","type":"main","index":0}]]},"Filter Unprocessed":{"main":[[{"node":"Check Skip","type":"main","index":0}]]},"Check Skip":{"main":[[{"node":"Skip Output","type":"main","index":0}],[{"node":"Loop Documents","type":"main","index":0}]]},"Loop Documents":{"main":[[{"node":"Wait for Categorization Complete","type":"main","index":0}],[{"node":"Call Parallel Processor document Categorizer","type":"main","index":0}]]},"Get Base Playbook":{"main":[[{"node":"Extract Dimensions","type":"main","index":0}]]},"Check Skip Analysis1":{"main":[[{"node":"Skip Analysis Output1","type":"main","index":0}],[{"node":"Call 'Phase 2 - Dimension Analysis (Document-Based) v3 ANK'","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Check Skip Analysis1","type":"main","index":0}]]},"Wait for Categorization Complete":{"main":[[{"node":"Check Completion Status","type":"main","index":0}]]},"Check Completion Status":{"main":[[{"node":"Verify All Categorized","type":"main","index":0}]]},"Verify All Categorized":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Call Parallel Processor document Categorizer":{"main":[[{"node":"Wait","type":"main","index":0}]]},"Wait":{"main":[[{"node":"Loop Documents","type":"main","index":0}]]}},"authors":"Laksh Agrawal","name":"Version 0e50e0c0","description":"","autosaved":false,"workflowPublishHistory":[{"createdAt":"2026-02-22T01:00:14.890Z","id":268,"workflowId":"1ynOLUqzJRBweKUj","versionId":"0e50e0c0-7b7d-4d3d-87b0-2199a1779f0f","event":"activated","userId":"ec164287-6cde-4606-b0c4-9d4cd30c3b98"}]}}